From 65817ae3fd3bc45b847073fdb0e791f7bbafd2e2 Mon Sep 17 00:00:00 2001
From: Duan Honghui <duanhh0103@thundersoft.com>
Date: Wed, 16 Dec 2020 14:37:51 +0800
Subject: [PATCH] pd phy diff for pd policy manager

Change-Id: I2969a81cfd1ebad47008fbddde461482e329a51f
---
 drivers/usb/pd/policy_engine.c | 157 ++++++++++++++++++++++++++++++++++++++++-
 include/linux/usb/usbpd.h      |  17 +++++
 2 files changed, 171 insertions(+), 3 deletions(-)

diff --git a/drivers/usb/pd/policy_engine.c b/drivers/usb/pd/policy_engine.c
index a86bac4..2fb840f 100644
--- a/drivers/usb/pd/policy_engine.c
+++ b/drivers/usb/pd/policy_engine.c
@@ -311,6 +311,7 @@ static void *usbpd_ipc_log;
 #define PD_SRC_PDO_VAR_BATT_MAX(pdo)		((pdo) & 0x3FF)
 
 #define PD_APDO_PPS(pdo)			(((pdo) >> 28) & 3)
+#define PD_APDO_PPS_POWER_LIMITED(pdo)		(((pdo) >> 27) & 1)
 #define PD_APDO_MAX_VOLT(pdo)			(((pdo) >> 17) & 0xFF)
 #define PD_APDO_MIN_VOLT(pdo)			(((pdo) >> 8) & 0xFF)
 #define PD_APDO_MAX_CURR(pdo)			((pdo) & 0x7F)
@@ -4177,7 +4178,7 @@ static ssize_t pdo_n_show(struct device *dev, struct device_attribute *attr,
 	usbpd_err(&pd->dev, "Invalid PDO index\n");
 	return -EINVAL;
 }
-
+#if 0
 static ssize_t select_pdo_store(struct device *dev,
 		struct device_attribute *attr, const char *buf, size_t size)
 {
@@ -4243,7 +4244,7 @@ static ssize_t select_pdo_store(struct device *dev,
 	mutex_unlock(&pd->swap_lock);
 	return ret ? ret : size;
 }
-
+#endif
 static ssize_t select_pdo_show(struct device *dev,
 		struct device_attribute *attr, char *buf)
 {
@@ -4251,7 +4252,120 @@ static ssize_t select_pdo_show(struct device *dev,
 
 	return scnprintf(buf, PAGE_SIZE, "%d\n", pd->selected_pdo);
 }
-static DEVICE_ATTR_RW(select_pdo);
+static DEVICE_ATTR_RO(select_pdo);
+
+static struct usbpd *g_pd;
+
+struct usbpd *usbpd_get_g_pd(void)
+{
+	return g_pd;
+}
+EXPORT_SYMBOL(usbpd_get_g_pd);
+
+int usbpd_fetch_pdo(struct usbpd *pd, struct usbpd_pdo *pdos)
+{
+	int ret = 0;
+	int pdo;
+	int i;
+
+	if (!pd || !pdos)
+		return -EINVAL;
+
+	mutex_lock(&pd->swap_lock);
+
+	if (pd->current_pr == PR_SRC) {
+		usbpd_err(&pd->dev, "not support in SRC mode\n");
+		ret = -ENOTSUPP;
+		goto out;
+	}
+
+	for (i = 0; i < 7; i++) {
+		pdo = pd->received_pdos[i];
+		if (pdo == 0)
+			break;
+
+		pdos[i].pos = i + 1;
+		pdos[i].pps = PD_APDO_PPS(pdo) == 0;
+		pdos[i].type = PD_SRC_PDO_TYPE(pdo);
+		pdos[i].pps_power_limited = PD_APDO_PPS_POWER_LIMITED(pdo);
+
+		if (pdos[i].type == PD_SRC_PDO_TYPE_FIXED) {
+			pdos[i].curr_ma = PD_SRC_PDO_FIXED_MAX_CURR(pdo) * 10;
+			pdos[i].max_volt_mv = PD_SRC_PDO_FIXED_VOLTAGE(pdo) * 50;
+			pdos[i].min_volt_mv = PD_SRC_PDO_FIXED_VOLTAGE(pdo) * 50;
+			usbpd_info(&pd->dev, "pdo:%d, Fixed supply volt: %d(mv) max curr:%d",
+					i+1, pdos[i].max_volt_mv,
+					pdos[i].curr_ma);
+		} else if (pdos[i].type == PD_SRC_PDO_TYPE_AUGMENTED) {
+			pdos[i].max_volt_mv = PD_APDO_MAX_VOLT(pdo) * 100;
+			pdos[i].min_volt_mv = PD_APDO_MIN_VOLT(pdo) * 100;
+			pdos[i].curr_ma     = PD_APDO_MAX_CURR(pdo) * 50;
+			usbpd_info(&pd->dev, "pdo:%d, PPS volt: %d(mv) max curr:%d",
+					i+1, pdos[i].max_volt_mv,
+					pdos[i].curr_ma);
+		} else {
+			usbpd_err(&pd->dev, "only fixed and pps pdo supported\n");
+		}
+	}
+
+out:
+	mutex_unlock(&pd->swap_lock);
+	return ret;
+}
+EXPORT_SYMBOL(usbpd_fetch_pdo);
+
+int usbpd_select_pdo(struct usbpd *pd, int pdo, int uv, int ua)
+{
+	int ret;
+
+	mutex_lock(&pd->swap_lock);
+
+	if (pd->current_pr != PR_SINK) {
+		ret = -ENOTSUPP;
+		goto out;
+	}
+
+	if (pdo < 1 || pdo > 7) {
+		usbpd_err(&pd->dev, "select_pdo: invalid PDO:%d\n", pdo);
+		ret = -EINVAL;
+		goto out;
+	}
+
+	ret = pd_select_pdo(pd, pdo, uv, ua);
+	if (ret)
+		goto out;
+
+	reinit_completion(&pd->is_ready);
+	pd->send_request = true;
+	if (!pd->sm_queued && !work_busy(&pd->sm_work))
+		kick_sm(pd, 0);
+	else {
+		usbpd_dbg(&pd->dev, "usbpd_select_pdo: pd->sm_queued is set\n");
+		ret = -EBUSY;
+		goto out;
+	}
+
+	/* wait for operation to complete */
+	if (!wait_for_completion_timeout(&pd->is_ready,
+			msecs_to_jiffies(1000))) {
+		usbpd_err(&pd->dev, "select_pdo: request timed out\n");
+		ret = -ETIMEDOUT;
+		goto out;
+	}
+
+	/* determine if request was accepted/rejected */
+	if (pd->selected_pdo != pd->requested_pdo ||
+			pd->current_voltage != pd->requested_voltage) {
+		usbpd_err(&pd->dev, "select_pdo: request rejected\n");
+		ret = -EINVAL;
+	}
+
+out:
+	pd->send_request = false;
+	mutex_unlock(&pd->swap_lock);
+	return ret;
+}
+EXPORT_SYMBOL(usbpd_select_pdo);
 
 static ssize_t rdo_show(struct device *dev, struct device_attribute *attr,
 		char *buf)
@@ -4364,6 +4478,41 @@ static int trigger_tx_msg(struct usbpd *pd, bool *msg_tx_flag)
 
 }
 
+
+int usbpd_get_pps_status(struct usbpd *pd, u32 *pps_status)
+{
+	int ret = 0;
+
+	if (pd->spec_rev == USBPD_REV_20)
+		return -EINVAL;
+
+	ret = trigger_tx_msg(pd, &pd->send_get_pps_status);
+	if (ret)
+		return ret;
+
+	*pps_status = pd->pps_status_db;
+
+	return 0;
+}
+EXPORT_SYMBOL(usbpd_get_pps_status);
+
+int usbpd_get_source_pdp_rating(struct usbpd *pd, int *pdp_rating)
+{
+	int ret = 0;
+
+	if (pd->spec_rev == USBPD_REV_20)
+		return -EINVAL;
+
+	ret = trigger_tx_msg(pd, &pd->send_get_src_cap_ext);
+	if (ret)
+		return ret;
+
+	*pdp_rating = pd->src_cap_ext_db[23];
+
+	return 0;
+}
+EXPORT_SYMBOL(usbpd_get_source_pdp_rating);
+
 static ssize_t get_src_cap_ext_show(struct device *dev,
 		struct device_attribute *attr, char *buf)
 {
@@ -4779,6 +4928,8 @@ struct usbpd *usbpd_create(struct device *parent)
 	ret = power_supply_reg_notifier(&pd->psy_nb);
 	if (ret)
 		goto del_inst;
+	
+	g_pd = pd;
 
 	/* force read initial power_supply values */
 	psy_changed(&pd->psy_nb, PSY_EVENT_PROP_CHANGED, pd->usb_psy);
diff --git a/include/linux/usb/usbpd.h b/include/linux/usb/usbpd.h
index 87dff93f..4ef23f1 100644
--- a/include/linux/usb/usbpd.h
+++ b/include/linux/usb/usbpd.h
@@ -159,4 +159,21 @@ static inline int usbpd_exit_mode(struct usbpd *pd, u16 svid, int mode,
 			SVDM_CMD_TYPE_INITIATOR, mode, vdo, vdo ? 1 : 0);
 }
 
+struct usbpd_pdo {
+	bool pps;
+	int type;
+	int max_volt_mv;
+	int min_volt_mv;
+	int curr_ma;
+	int pos;
+	bool pps_power_limited;
+};
+
+struct usbpd *usbpd_get_g_pd(void);
+int usbpd_get_pps_status(struct usbpd *pd, u32 *status);
+int usbpd_fetch_pdo(struct usbpd *pd, struct usbpd_pdo *pdos);
+int usbpd_select_pdo(struct usbpd *pd, int pdo, int uv, int ua);
+int usbpd_get_source_pdp_rating(struct usbpd *pd, int *pdp_rating);
+
+
 #endif /* __LINUX_USB_USBPD_H */
-- 
2.7.4

